%========================= Algorithm Design =========================
This chapter presents how the application is designed at a logical level and describes the 
main algorithms used by the application.

\subsection{Planarity testing}

The first algorithm used by the application is the planarity testing method known as "path addition". In 
order to properly present this algorithm, we must first introduce the necessary notions regarding graph planarity 
and methods of testing this property.

\subsubsection{Planarity property and criteria}

A given graph G=(V,E) is planar if it can be drawn on a plane and its edges never cross each other, i.e. they 
intersect only at their endpoints. This type of drawing is also known as a planar embedding of the graph.

In order to determine if a graph possesses the planarity property, a series of theorems and criteria have been 
stated over the years. Amongst the first of these criteria is a theorem published by the Polish mathematician 
Kazimierz Kuratowski in 1930. The theorem deals with subdivisions, i.e. graphs which result from inserting vertices 
into edges. It states that a planar graph shall not contain a subdivision of the forbidden graphs K5(the complete 
graph on five vertices) or K3,3(complete bipartite graph on six vertices, three of which connect to each of the other 
three, also known as the utility graph). It is formulated as follows:

A finite graph is planar if and only if it does not contain a subgraph that is a subdivision of K5 or K3,3 .

Another important theorem which deals with planarity was formulated by the German mathematician Klaus Wagner. 
This theorem takes into consideration graph minors instead of subdivisions. A graph H is called a minor of a given 
graph G if H is obtained by deleting vertexes and edges or by contracting edges. The Wagner theorem states that 
a finite graph is planar if and only if it does not have K5 or K3,3 as a minor.

While these theorems manage to correctly define the planarity problem in a mathematical way, they are not optimal 
criterions to use in practice. The main reason is efficiency; we would like the complexity of such an algorithm 
to be linear O(n). In practice, there exist other theorems and criteria which fit in the linear complexity. For 
example, given a finite, connected planar graph with \iv the number of vertices, \ie the number of edges and 
\if the number of faces (regions bounded by edges, including the outer, infinitely large region), the following 
hold true:

Theorem 1: If \iv ≥ 3 then \ie ≤ 3\iv − 6;
Theorem 2: If \iv ≥ 3 and there are no cycles of length 3, then \ie ≤ 2\iv − 4;
Theorem 3: v − e + f = 2 (Euler's formula).

Unfortunately, these theorems are only necessary conditions, not sufficient conditions. They can only be used to 
prove that a graph is not planar; they cannot prove that a graph is planar.

\subsubsection{Vertex addition method}

The edge addition algorithm is the result an intensive research started in the 1960s by Abraham Lempel, Shimon Even
and Cederbaum. They created an algorithm to determine whether a graph is planar or not and embed it in the plane in 
O(n2) time. Later on, Even and Tarjan developed a method to generate the st-numbering of a graph in linear O(n) time.

***describe st-numbering here***

Finally, Kellogg Booth and George Lueker created a data structure which represents the possible embeddings of a graph 
(or, in practice, induced subgraphs of a graph) called a PQ-tree. Using this data structure and the previous methods, 
they managed to created a linear time algorithm to determine planarity and possible embeddings. We will next present 
the general steps of an implementation of the Vertex addition method as proposed by Norishige Chiba and Takao Nishizekii.

First, it computes the st-numbering of the given graph. It then creates a PQ-tree which contains only one P node, the 
source, and all the other nodes are leaves. Next, a loop is entered which, for every leaf node, shall perform two steps:

a) A reduction step which attempts to gather all matching leaves into a P node which respects the st-numbering. If this 
step fails, then the graph is not planar.

b) A vertex addition step, in which full nodes are replaced by a single P node and all the neighbours of that node 
numbered higher than itself are added as leaves.

Figures x to y below present the steps of this algorithm applied on a graph G(3,3).

****** Insert figures here ******


\subsection{Graph placement}

Graph placement refers to assigning a position (set of coordinates) to each node of the graph in the space where 
the graph has to be represented.

We saw in the previous chapter that algorithms which determine if a graph is planar can also generate its 
embedings. However, this is not the same as actually drawing the graph. In reality, we are constrained by the 
limitations of the space in which we want to draw the diagram. Therefore, even though we know that a possible 
arrangement of the nodes will allow us to represent the graph in a plane, we cannot be certain that the 
representation is feasible or understandable. Furthermore, one may want to draw even graphs which are not planar, 
knowing that two or more of its edges will cross one another.

For this reason, a logical positioning of each node in the given plane is required. This step greatly facilitates 
the routing process and also helps reduce the time and complexity of said operation.

The placing algorithm presented in this thesis combines methods used by algorithms found in popular diagram drawing open 
source software(Grid placement, Force-directed placement) with notions from genetic algorithms (popultions, fitness functions).
We shall first present the ideas behind these algorithms and then discuss how they are used in the implementation.

\subsubsection{Grid placement}

Grid placement is one of the most popular and most used techniques by diagram drawing algorithms. It splits the space in 
which the representation is done into a grid and then starts placing the nodes in a certain order. Different approaches 
can be found here, depending on the type of the graph. 

Trees are often placed in layeres. The root of the tree is first fixed on an edge of the grid, and then each level of the tree 
visited in breadth-first order forms a layer of nodes. Layers can be arranged vertically or horizontally, depending on the implementation.

More general graphs may also follow this pattern, by computing the spanning tree of the graph and placing nodes as stated above, 
starting with the spanning tree's root. Other approaches for general graphs may place and pin the node with the highest number of 
connections in the middle of the grid.

The advantages of this method are represented by its ease of implementation, small consumption of resources and low complexity. A main drawback 
is that it generally interfers with the routing process and does not facilitate it. It also poses the risk of drawing planar graphs as though 
they were non-planar, i.e. intersecting various edges.


***** Aici poze cu grid-uri *****

\subsubsection{Force directed placement}

Force directed placement is a technique which borrows concepts from physiques. In order to apply this method, one must model the graph as a 
physical system in which elements (nodes) interract with each other through forces. Connected nodes will be pulled towards each other by 
attraction forces (consider gravity), while unrelated nodes reject each other (consider magnetic forces). These effect of these forces is 
applied continuously until the system reaches stability.

Using such a technique will yield a graph placement which has the strongly connected nodes pulled in the middle of the assigned drawing spaced, while the 
individual or loosely connected nodes are pushed towards the edges. The same holds if the graph is split into multiple independet conex components: 
the nodes of each component shall be pulled towards each other, while the individual components will reject one another.

***** Poze cu mici galaxii dinastea ******

This approach is better suited to ease the routing process and reduce its time and complexity. It is less likely that planar graphs shall be 
improperly drawn and routes will be shorter and clearer. However, unlike Grid placement, it is an iterative process which may take considerable 
amounts of time to reach stability, while also consuming more resources.

\subsubsection{Al meu algorithm mirific}
