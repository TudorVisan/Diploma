Diagrams are tools which are widely used in various domains in order to represent
concepts, hierarchies, architectures etc. In software engineering, they can be found as
an UML(Unified Modeling Language) visualisation of a system or program or as an inheritance
tree in the case of OOP(Object Oriented Programming) languages. Diagrams are also present 
in the hardware world where their usage includes: logical representation of an FSM(Finite State Machine), 
data flow between components, on-chip dependencies between components. However, there is a field in 
which diagrams are a key part of development: hardware design and verification. In the case of hardware design, 
be it ASIC(Application Specific Integrated Circuit), FPGA(Field Programmable Gate Array), processors, memories or
microcontrollers, diagrams are used to describe the individual blocks which are put together to form the respective chip, 
to represent the way modules are connected at a logical level or to show how data is passed and manipulated by each component. 
In hardware verification, they are used to represent hierarchies and inheritance amongst specific units such as agents, 
sequencers, test scoreboards and general test flows, often corresponding with the guidelines of accepted methodologies such
as OVM(Open Verification Methodology) and UVM(Universal Verification Methodology). Therefore, one can assert that diagrams 
are instrumental in all stages of hardware design and verification.

Despite being an important part of the hardware design and verification world, diagrams do not receive the required attention 
from the developer community. While HDLs(Hardware Description Languages) have been gaining popularity over the years and IDEs 
have been developing to support them, diagrams have not received adequate attention from the community. It is often 
overlooked that their main utility lies in understanding and maintaining the coherence and logical flow of a design
or a verification testbench. 

Usually, a hardware design consists of a number of design elements which can range from hundreds to thousands of design elements; 
the equivalent of a graph with the same number of nodes. Representing such a design as a diagram would be, in turn, equivalent to 
drawing said graph in a plane. A given graph must pass through three steps in order to obtain a diagram representation: planarity 
testing, node placement and connection routing. For current algorithms and software, this is a well known problem which is difficult 
to solve in a reasonable amount of time and also yield a readable and easy to understand result. However, there are methods and 
algorithms which can be combined to obtain a feasible diagram representation. 

The layout and routing solution which is presented in this study combines techniques used in current solutions with newer algorithms 
in an attempt to obtain representations which respect the following criteria:

\begin{itemize}

\item Coherency: The diagram should be easy to understand and follow. Each connection in the diagram represents either 
data paths(BUS) or logical connections between components. For this reason the user must be able to understand where these paths start, 
where they end and what components they connect.

\item Correctness: As any algorithm, the solution must maintain the correctness of the model when representing it. All nodes have to be
included and all edges represented according to the corresponding adjacency matrix of the given graph.

\item Planarity: Refers to the property of the given graph to be represented in the two dimensional plane. A planar graph does not have 
intersecting edges. It is expected that the representation preserves the planarity property of the graph.

\item Orthogonality: Edges between nodes are represented as orthogonal connectors. Orthogonality implies that a path is composed only
of perpendicular segments and contains a minimum number of bends. Paths shall not overlap any node.

\end{itemize}
